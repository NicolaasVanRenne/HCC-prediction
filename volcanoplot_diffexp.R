###################################################
#  volcanoplot diffexp poor vs good 	
###################################################

#set working directory
	setwd("C:/my_dir")
	
#load library
	library(ggplot2)
	library(dplyr)
	
# 1. Validation set
################################################################################################

	# load NTP prediction
	{	
		##############################################################
		# read NTP file for good/int/poor prognosis
		##############################################################
			input.NTP.file = "validation_NTP_prediction_result.txt"
			select.p = "BH.FDR"
			p.cutoff = 0.05
			
			#read NTP prediction file generated by NTPez.R 
			NTP.df <- read.table(file=input.NTP.file, header=T, sep="\t") 
			colnames(NTP.df)[1:2] <- c("SampleName","PredictedCls") #Change first two colnames: "SampleName","PredictedCls"
			rownames(NTP.df) <- NTP.df$SampleName
			
			if(select.p == "BH.FDR"){NTP.df.intermediate    <- cbind(NTP.df$SampleName,NTP.df$PredictedCls,NTP.df$BH.FDR, rep(0,nrow(NTP.df)))}
			if(select.p == "nominal.p"){NTP.df.intermediate <- cbind(NTP.df$SampleName,NTP.df$PredictedCls,NTP.df$nominal.p, rep(0,nrow(NTP.df)))}
				for(i in 1:nrow(NTP.df.intermediate)){
					if(NTP.df.intermediate[i,3] < p.cutoff) { NTP.df.intermediate[i,4] <- NTP.df.intermediate[i,2] }else{ NTP.df.intermediate[i,4] <- "intermediate"}
					if(NTP.df.intermediate[i,4] == 1) { NTP.df.intermediate[i,4] <- "poor"}
					if(NTP.df.intermediate[i,4] == 2) { NTP.df.intermediate[i,4] <- "good"}
				}
			NTP.df$IntCls <- NTP.df.intermediate[,4]
		}
		
	#load dataset
		input.gene.expression.file = "data_files/collapsed_data/GSE237331_validation_RPM.gct"
	{
		exp.dataset<-read.delim(file=input.gene.expression.file,header=T,skip=2,check.names=F)
		rownames(exp.dataset) <- exp.dataset[,1]
		exp.dataset <- exp.dataset[,-c(1:2)]
		
		set.power2=FALSE
			if(set.power2 == TRUE){
				gene.dataset <- 2^gene.dataset
			}
		
		set.log10=FALSE
		if(set.log10 == TRUE){
			exp.dataset <- log(exp.dataset + 1)
		}
	}
	
	#partition poor and good
		exp.dataset.poor <- exp.dataset[,NTP.df$IntCls %in% "poor"]
		exp.dataset.good <- exp.dataset[,NTP.df$IntCls %in% "good"]
	
	#create correlation volcano plot
	#note: S2NR reproduces the signal to noise ratio used in GSEA GUI v4.1.0
		set.metric = "log2fc" # "S2NR" or #log2fc
	
		if(set.metric=="S2NR"){ 
			sd1 <- apply(exp.dataset.poor,1,sd)
			m1  <- apply(exp.dataset.poor,1,mean)
				adapt.sd1 <- which( (sd1 / abs(m1)) < 0.2) #which stdevs are less than 0.2 mean
				correction.factor.sd1 <- rep(1, length(sd1)) #create correction vector
				correction.factor.sd1[adapt.sd1] <- 0.2/(sd1[adapt.sd1]/m1[adapt.sd1]) #calculate correction factor for all stdevs whose stdevs are less than 0.2 mean
				sd1 <- sd1*correction.factor.sd1 # now that the correction is applied, stdevs are 0.2 of mean or bigger
			sd2 <- apply(exp.dataset.good,1,sd)
			m2  <- apply(exp.dataset.good,1,mean)
				adapt.sd2 <- which( (sd2 / abs(m2)) < 0.2) #which stdevs are less than 0.2 mean
				correction.factor.sd2 <- rep(1, length(sd2)) #create correction vector
				correction.factor.sd2[adapt.sd2] <- 0.2/(sd2[adapt.sd2]/m2[adapt.sd2]) #calculate correction factor for all stdevs whose stdevs are less than 0.2 mean
				sd2 <- sd2*correction.factor.sd2 # now that the correction is applied, stdevs are 0.2 of mean or bigger
			metric <- (m1-m2)/(sd1+sd2)
		}		
				

		if(set.metric=="log2fc"){
			poor.mean <- apply(exp.dataset.poor,1,mean)
			good.mean <- apply(exp.dataset.good,1,mean)
			
			fc <- poor.mean/good.mean
			log2fc <- fc
			log2fc[fc>1] <- log(log2fc[fc>1],2)
			
			
			log2fc[fc<1] <- (1/log2fc[fc<1])
			log2fc[fc<1] <- -1*log(log2fc[fc<1],2)
			metric <- log2fc
		}
		


		#set test for p values
		set.test ="wilcoxon" #wilcoxon" or "ttest"
		
		#calculate p values: "wilcoxon" or "ttest"
			if(set.test=="wilcoxon"){
				pvalue <- rep(0,nrow(exp.dataset))
					for(i in seq_along(pvalue)){
						pvalue[i] <- wilcox.test(as.numeric(exp.dataset.poor[i,]),as.numeric(exp.dataset.good[i,]))$p.value
					}
			}

			if(set.test=="ttest"){
				pvalue <- rep(0,nrow(exp.dataset))
					for(i in seq_along(pvalue)){
						pvalue[i] <- t.test(as.numeric(exp.dataset.poor[i,]),as.numeric(exp.dataset.good[i,]))$p.value
					}
			}

		#adjust pvalue with Benjamini Hochberg
			adjust.p=TRUE
			
			if(adjust.p==TRUE){
				padjusted <- p.adjust(pvalue, method = "BH", n = length(pvalue))
				volcano.df <- cbind(metric,padjusted)
				colnames(volcano.df) <- c("metric","padjusted")
			}
			
			if(adjust.p==FALSE){
				volcano.df <- cbind(metric,pvalue)
				colnames(volcano.df) <- c("metric","pvalue")
			}
		
		#basic plot
			volcano.df <- as.data.frame(volcano.df)
			ggplot(data=volcano.df, aes(x=metric, y=-log10(padjusted))) + geom_point() + theme_classic() #basic plot, to set cutoffs of significance
		
		
	#Publication quality volcano plot
			#load poor and good prognosis genes
				signature.df <- read.delim(file="output/training_RPM_filtered_signature_result_ordered.txt",header=T,check.names=F)		
				poor.genes <- signature.df[signature.df$statistic > 0, 1]
				good.genes <- signature.df[signature.df$statistic < 0, 1]
				
			#add column of colored dots
				volcano.df$Direction <- "None"
				#volcano.df$Direction[volcano.df$statistic > 0 & volcano.df$nominal.p < 0.025] <- "HCC-incidence correlated" 
				#volcano.df$Direction[volcano.df$statistic < 0 & volcano.df$nominal.p < 0.025] <- "HCC-incidence anti-correlated"
				volcano.df$Direction[rownames(volcano.df) %in% poor.genes] <- "HCC-incidence correlated" 		
				volcano.df$Direction[rownames(volcano.df) %in% good.genes] <- "HCC-incidence anti-correlated"			
				
				volcano.df$Direction <- as.factor(volcano.df$Direction)
				volcano.df$Direction <- factor(volcano.df$Direction, levels = c("HCC-incidence anti-correlated", "None", "HCC-incidence correlated"))

			# partially transparent points by setting `alpha`
				linecolors <- c("navy", "darkgrey", "firebrick")
				fillcolors <- c("navy", "darkgrey", "firebrick")
				
			#set plot order
				plot.order <- rep(0,nrow(volcano.df))
				plot.order[volcano.df$Direction =="None"] <- 1
				plot.order[volcano.df$Direction =="HCC-incidence anti-correlated"] <- 2
				plot.order[volcano.df$Direction =="HCC-incidence correlated"] <- 3
				volcano.df$plotorder <- plot.order
				
			#log10 pval
				ggplot(volcano.df %>% arrange(plotorder),  aes(x=metric, y=-log10(padjusted), col=Direction, fill=Direction)) + 
					geom_point(shape = 21, alpha = 0.2, size = 1) +
					scale_color_manual(values=linecolors) +
					scale_fill_manual(values=fillcolors) +
					geom_hline(yintercept=-log10(0.05), linetype='dashed', col = 'darkgrey') +
					labs(y= "-log10 adjusted p value", x = set.metric) +
					theme_classic() 
					
			#add labels
				#select genes to label
					UP.genes <- c("IGHA2","IGHA1")
							
					volcano.df$genelabel <- NA
					volcano.df$genelabel[rownames(volcano.df) %in% UP.genes] <- rownames(volcano.df)[rownames(volcano.df) %in% UP.genes]
					#volcano.df$genelabel[rownames(volcano.df) %in% DN.genes] <- rownames(volcano.df)[rownames(volcano.df) %in% DN.genes]

					library(ggrepel)
					options(ggrepel.max.overlaps = Inf)
				
					library(ggrepel)
					p=ggplot(volcano.df %>% arrange(plotorder),  aes(x=metric, y=-log10(padjusted), col=Direction, fill=Direction, label=genelabel)) + 
						geom_point(shape = 21, alpha = 0.5, size = 1) +
						xlim(c(-3,5))+
						scale_color_manual(values=linecolors) +
						scale_fill_manual(values=fillcolors) +
						geom_hline(yintercept=-log10(0.05), linetype='dashed', col = 'black') +
						geom_vline(xintercept=c(-1,1), linetype='dashed', col = 'black') +
						labs(y= "-log10(adjusted p-value)", x = set.metric) +
						theme_classic()	+
							theme(axis.text.x = element_text(size = 20, color="black"), axis.title.x = element_text(size = 20, color="black")) +
							theme(axis.text.y = element_text(size = 20, color="black"), axis.title.y = element_text(size = 20, color="black")) +
							theme(legend.position="top", legend.text = element_text(size=10, color="black"), legend.title= element_text(size=10, color="black")) +guides(col=guide_legend(override.aes = list(size=5), nrow=3)) +
							geom_text_repel(
								size   = 5,
								force        = 1,
								nudge_x      = 10,
								direction    = "y",
								segment.size = 0.2, #	line segment thickness
								show.legend=FALSE
							) 
					p

		
